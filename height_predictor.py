# -*- coding: utf-8 -*-
"""height_predictor

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/18ywYKsA7B0tZfWWH6FdLceJJCh_RmaVL

#Imports
"""

import tensorflow as tf
import numpy as np
import json
import os
import cv2
from PIL import Image, ImageDraw
import matplotlib.pyplot as plt
from sklearn.model_selection import train_test_split
import albumentations as A
from tensorflow.keras.applications import ResNet50
from tensorflow.keras.layers import *
from tensorflow.keras.models import Model
from tensorflow.keras.optimizers import Adam
from tensorflow.keras.callbacks import ModelCheckpoint, EarlyStopping, ReduceLROnPlateau
import warnings
warnings.filterwarnings('ignore')
from google.colab import drive
drive.mount('/content/drive')

"""#Load the DeepLabV3 Model"""

import tensorflow as tf
from tensorflow.keras.layers import *
from tensorflow.keras.models import Model
from keras.saving import register_keras_serializable

# Register the custom resize_tensor function
@register_keras_serializable()
def resize_tensor(inputs):
    tensor_to_resize, reference_tensor = inputs
    # Cast to float32 to ensure consistency
    tensor_to_resize = tf.cast(tensor_to_resize, tf.float32)
    reference_shape = tf.shape(reference_tensor)[1:3]
    return tf.image.resize(tensor_to_resize, reference_shape)

# Define custom metrics and loss functions
def dice_coefficient(y_true, y_pred, smooth=1e-6):
    """Dice coefficient for segmentation"""
    # Ensure both tensors are float32
    y_true = tf.cast(y_true, tf.float32)
    y_pred = tf.cast(y_pred, tf.float32)

    y_true_f = tf.keras.backend.flatten(y_true)
    y_pred_f = tf.keras.backend.flatten(y_pred)
    intersection = tf.keras.backend.sum(y_true_f * y_pred_f)
    return (2. * intersection + smooth) / (tf.keras.backend.sum(y_true_f) + tf.keras.backend.sum(y_pred_f) + smooth)

def dice_loss(y_true, y_pred):
    """Dice loss for segmentation"""
    return 1 - dice_coefficient(y_true, y_pred)

def combined_loss(y_true, y_pred):
    """Combined loss: Categorical crossentropy + Dice loss"""
    # Ensure both tensors are float32
    y_true = tf.cast(y_true, tf.float32)
    y_pred = tf.cast(y_pred, tf.float32)

    ce_loss = tf.keras.losses.categorical_crossentropy(y_true, y_pred)
    dice_loss_val = dice_loss(y_true, y_pred)
    return ce_loss + dice_loss_val

def iou_score(y_true, y_pred):
    """IoU score for segmentation"""
    # Ensure both tensors are float32
    y_true = tf.cast(y_true, tf.float32)
    y_pred = tf.cast(y_pred, tf.float32)

    y_true_f = tf.keras.backend.flatten(y_true)
    y_pred_f = tf.keras.backend.flatten(y_pred)
    intersection = tf.keras.backend.sum(y_true_f * y_pred_f)
    union = tf.keras.backend.sum(y_true_f) + tf.keras.backend.sum(y_pred_f) - intersection
    return intersection / (union + 1e-6)

def load_deeplab_model(model_path):
    """
    Load the DeepLab model with all custom objects
    """
    # Set default dtype to float32
    tf.keras.backend.set_floatx('float32')

    # Define custom objects dictionary
    custom_objects = {
        'resize_tensor': resize_tensor,
        'dice_coefficient': dice_coefficient,
        'dice_loss': dice_loss,
        'combined_loss': combined_loss,
        'iou_score': iou_score
    }

    # Load the model
    model = tf.keras.models.load_model(
        model_path,
        custom_objects=custom_objects
    )

    print("Model loaded successfully!")
    print(f"Model input shape: {model.input_shape}")
    print(f"Model output shape: {model.output_shape}")

    return model

# Usage example:
if __name__ == "__main__":
    # Mount Google Drive first
    from google.colab import drive
    drive.mount('/content/drive')

    # Load your model
    model_path = '/content/drive/MyDrive/AutonomousDrone/Code/deeplabv3_building_model.h5'
    model = load_deeplab_model(model_path)

"""#Create masks based on images"""

from google.colab import drive
drive.mount('/content/drive')

!pip install opencv-python-headless

import os
import json
import cv2
import numpy as np
from matplotlib import pyplot as plt
from tqdm import tqdm

from glob import glob

def find_image(image_dir, base_name):
    """
    Tries to find an image file in the directory that matches the base name
    with any image extension (.jpg, .png, etc.).
    """
    candidates = glob(os.path.join(image_dir, base_name + '.*'))
    return candidates[0] if candidates else None

# Path to VIA JSON
VIA_JSON_PATH = '/content/drive/MyDrive/AutonomousDrone/Building Dataset/training_data_207.json'

# Folder where images are stored
IMAGES_DIR = '/content/drive/MyDrive/AutonomousDrone/Building Dataset/Combined Data'

# Output folder for masks
MASKS_OUTPUT_DIR = '/content/drive/MyDrive/AutonomousDrone/BuildingDataset/Arjun/masks'

# Load the JSON
with open(VIA_JSON_PATH) as f:
    data = json.load(f)

metadata = data['_via_img_metadata']  # This is the main data

# Iterate through each annotation
for key, ann in tqdm(metadata.items()):
    filename = ann['filename']
    regions = ann['regions']
    img_path = os.path.join(IMAGES_DIR, filename)

    # Load image
    img = cv2.imread(img_path)
    if img is None:
        print(f"Image not found: {filename}")
        continue

    height, width = img.shape[:2]
    mask = np.zeros((height, width), dtype=np.uint8)

    # Draw polygons on mask
    for region in regions:
        shape = region['shape_attributes']
        if shape['name'] != 'polygon':
            continue  # Skip non-polygon shapes
        x_points = shape['all_points_x']
        y_points = shape['all_points_y']
        points = np.array(list(zip(x_points, y_points)), dtype=np.int32)
        cv2.fillPoly(mask, [points], 255)

    # Save mask
    mask_filename = os.path.splitext(filename)[0] + '_mask.png'
    cv2.imwrite(os.path.join(MASKS_OUTPUT_DIR, mask_filename), mask)

"""#Predict new masks

"""

import tensorflow as tf
import numpy as np
import cv2
import os
import glob
from PIL import Image
from tqdm import tqdm

def save_predicted_masks(model, input_dir, output_dir, target_size=(512, 512)):
    """
    Generate and save predicted masks for all images in a directory

    Args:
        model: Your loaded DeepLab model
        input_dir: Directory containing input images
        output_dir: Directory to save predicted masks
        target_size: Model input size (height, width) - should match training size

    Returns:
        Number of successfully processed images
    """

    # Create output directory
    os.makedirs(output_dir, exist_ok=True)

    # Find all image files
    image_extensions = ['*.png', '*.jpg', '*.jpeg', '*.tiff', '*.bmp', '*.PNG', '*.JPG', '*.JPEG']
    image_files = []
    for ext in image_extensions:
        image_files.extend(glob.glob(os.path.join(input_dir, ext)))

    if not image_files:
        print(f"No image files found in {input_dir}")
        return 0

    image_files.sort()
    print(f"Found {len(image_files)} images to process")

    successful_count = 0
    failed_files = []

    for image_path in tqdm(image_files, desc="Generating masks"):
        try:
            filename = os.path.basename(image_path)
            name_without_ext = os.path.splitext(filename)[0]

            # Load and preprocess image
            image = cv2.imread(image_path)
            image_rgb = cv2.cvtColor(image, cv2.COLOR_BGR2RGB)
            original_shape = image_rgb.shape

            # Resize to model input size
            resized_image = cv2.resize(image_rgb, target_size)

            # Normalize and add batch dimension
            normalized_image = resized_image.astype(np.float32) / 255.0
            batched_image = np.expand_dims(normalized_image, axis=0)

            # Predict
            prediction = model.predict(batched_image, verbose=0)

            # Convert prediction to binary mask
            pred = prediction[0]  # Remove batch dimension
            class_mask = np.argmax(pred, axis=-1)  # Get class predictions
            binary_mask = (class_mask == 1).astype(np.uint8)  # Buildings = class 1

            # Resize back to original image size
            original_height, original_width = original_shape[:2]
            resized_mask = cv2.resize(binary_mask, (original_width, original_height),
                                    interpolation=cv2.INTER_NEAREST)

            # Convert to 0-255 range for saving
            mask_image = (resized_mask * 255).astype(np.uint8)

            # Save mask
            mask_filename = f"{name_without_ext}_mask.png"
            mask_path = os.path.join(output_dir, mask_filename)

            # Save using PIL
            mask_pil = Image.fromarray(mask_image, mode='L')
            mask_pil.save(mask_path)

            successful_count += 1

        except Exception as e:
            print(f"Error processing {filename}: {str(e)}")
            failed_files.append(filename)
            continue

    # Print summary
    print(f"\n=== MASK GENERATION COMPLETE ===")
    print(f"Successfully processed: {successful_count}/{len(image_files)} images")
    print(f"Masks saved to: {output_dir}")

    if failed_files:
        print(f"Failed to process: {failed_files}")

    return successful_count

# Simple usage function
def generate_all_masks(model, input_folder, output_folder):
    """
    Simplified function to generate all masks

    Args:
        model: Your loaded DeepLab model
        input_folder: Path to folder with input images
        output_folder: Path to folder where masks will be saved
    """

    return save_predicted_masks(
        model=model,
        input_dir=input_folder,
        output_dir=output_folder,
        target_size=(512, 512)
    )



# Set your paths
input_images_folder = "/content/drive/MyDrive/AutonomousDrone/Building Dataset/Arjun/Drone Images"
output_masks_folder = "/content/drive/MyDrive/AutonomousDrone/Building Dataset/Arjun/Drone Predictions"

# Generate and save all masks
count = generate_all_masks(model, input_images_folder, output_masks_folder)
print(f"Generated {count} masks!")

"""#Create side-by-side visualizations


"""

import matplotlib.pyplot as plt
import numpy as np
import cv2
import os
import glob
from PIL import Image
import re

def find_matching_files(original_dir, annotated_dir, predicted_dir):
    """
    Find matching files across three directories

    Args:
        original_dir: Directory with original images
        annotated_dir: Directory with annotated masks
        predicted_dir: Directory with predicted masks

    Returns:
        List of tuples (original_path, annotated_path, predicted_path)
    """
    # Get all files from each directory
    image_extensions = ['*.png', '*.jpg', '*.jpeg', '*.tiff', '*.bmp', '*.PNG', '*.JPG', '*.JPEG']

    # Find original images
    original_files = []
    for ext in image_extensions:
        original_files.extend(glob.glob(os.path.join(original_dir, ext)))

    # Find annotated masks
    annotated_files = []
    for ext in image_extensions:
        annotated_files.extend(glob.glob(os.path.join(annotated_dir, ext)))

    # Find predicted masks
    predicted_files = []
    for ext in image_extensions:
        predicted_files.extend(glob.glob(os.path.join(predicted_dir, ext)))

    # Create dictionaries for easier matching
    original_dict = {}
    for file_path in original_files:
        filename = os.path.basename(file_path)
        base_name = os.path.splitext(filename)[0]
        original_dict[base_name] = file_path

    annotated_dict = {}
    for file_path in annotated_files:
        filename = os.path.basename(file_path)
        base_name = os.path.splitext(filename)[0]
        # Remove common suffixes like "_mask", "_annotated", etc.
        base_name = re.sub(r'(_mask|_annotated|_gt|_groundtruth)$', '', base_name)
        annotated_dict[base_name] = file_path

    predicted_dict = {}
    for file_path in predicted_files:
        filename = os.path.basename(file_path)
        base_name = os.path.splitext(filename)[0]
        # Remove common suffixes like "_mask", "_predicted", etc.
        base_name = re.sub(r'(_mask|_predicted|_pred)$', '', base_name)
        predicted_dict[base_name] = file_path

    # Find matching triplets
    matches = []
    for base_name in original_dict.keys():
        if base_name in annotated_dict and base_name in predicted_dict:
            matches.append((
                original_dict[base_name],
                annotated_dict[base_name],
                predicted_dict[base_name]
            ))

    return matches

def load_and_prepare_image(image_path, is_mask=False):
    """
    Load and prepare image for display

    Args:
        image_path: Path to image file
        is_mask: Whether this is a mask (binary) image

    Returns:
        Processed image array
    """
    # Load image
    image = cv2.imread(image_path)
    if image is None:
        # Try with PIL if cv2 fails
        image = np.array(Image.open(image_path))

    # Convert BGR to RGB if needed
    if len(image.shape) == 3 and image.shape[2] == 3:
        if not is_mask:  # Only convert color images, not masks
            image = cv2.cvtColor(image, cv2.COLOR_BGR2RGB)

    # Handle mask images
    if is_mask:
        if len(image.shape) == 3:
            # Convert to grayscale if it's a color mask
            image = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)
        # Ensure binary mask is in 0-1 range for display
        image = image.astype(np.float32) / 255.0
    else:
        # Ensure color image is in 0-1 range for display
        image = image.astype(np.float32) / 255.0

    return image

def create_comparison_plot(original_path, annotated_path, predicted_path, save_path=None, show_plot=True):
    """
    Create side-by-side comparison plot

    Args:
        original_path: Path to original image
        annotated_path: Path to annotated mask
        predicted_path: Path to predicted mask
        save_path: Path to save the comparison (optional)
        show_plot: Whether to display the plot

    Returns:
        Figure object
    """
    # Load images
    original_img = load_and_prepare_image(original_path, is_mask=False)
    annotated_mask = load_and_prepare_image(annotated_path, is_mask=True)
    predicted_mask = load_and_prepare_image(predicted_path, is_mask=True)

    # Create figure
    fig, axes = plt.subplots(1, 3, figsize=(18, 6))

    # Original image
    axes[0].imshow(original_img)
    axes[0].set_title(f'Original Image\n{os.path.basename(original_path)}', fontsize=12, fontweight='bold')
    axes[0].axis('off')

    # Annotated mask
    axes[1].imshow(annotated_mask, cmap='gray')
    axes[1].set_title(f'Ground Truth Mask\n{os.path.basename(annotated_path)}', fontsize=12, fontweight='bold')
    axes[1].axis('off')

    # Predicted mask
    axes[2].imshow(predicted_mask, cmap='gray')
    axes[2].set_title(f'Predicted Mask\n{os.path.basename(predicted_path)}', fontsize=12, fontweight='bold')
    axes[2].axis('off')

    plt.tight_layout()

    # Save if requested
    if save_path:
        plt.savefig(save_path, dpi=300, bbox_inches='tight')
        print(f"Comparison saved to: {save_path}")

    # Show if requested
    if show_plot:
        plt.show()
    else:
        plt.close()

    return fig

def create_overlay_comparison(original_path, annotated_path, predicted_path, save_path=None, show_plot=True):
    """
    Create comparison with masks overlaid on original image

    Args:
        original_path: Path to original image
        annotated_path: Path to annotated mask
        predicted_path: Path to predicted mask
        save_path: Path to save the comparison (optional)
        show_plot: Whether to display the plot
    """
    # Load images
    original_img = load_and_prepare_image(original_path, is_mask=False)
    annotated_mask = load_and_prepare_image(annotated_path, is_mask=True)
    predicted_mask = load_and_prepare_image(predicted_path, is_mask=True)

    # Resize masks to match original image if needed
    if original_img.shape[:2] != annotated_mask.shape[:2]:
        annotated_mask = cv2.resize(annotated_mask, (original_img.shape[1], original_img.shape[0]))
    if original_img.shape[:2] != predicted_mask.shape[:2]:
        predicted_mask = cv2.resize(predicted_mask, (original_img.shape[1], original_img.shape[0]))

    # Create figure
    fig, axes = plt.subplots(2, 2, figsize=(16, 12))

    # Original image
    axes[0, 0].imshow(original_img)
    axes[0, 0].set_title('Original Image', fontsize=14, fontweight='bold')
    axes[0, 0].axis('off')

    # Ground truth overlay
    axes[0, 1].imshow(original_img)
    axes[0, 1].imshow(annotated_mask, cmap='Reds', alpha=0.5)
    axes[0, 1].set_title('Original + Ground Truth (Red)', fontsize=14, fontweight='bold')
    axes[0, 1].axis('off')

    # Predicted overlay
    axes[1, 0].imshow(original_img)
    axes[1, 0].imshow(predicted_mask, cmap='Blues', alpha=0.5)
    axes[1, 0].set_title('Original + Predicted (Blue)', fontsize=14, fontweight='bold')
    axes[1, 0].axis('off')

    # Both overlays
    axes[1, 1].imshow(original_img)
    axes[1, 1].imshow(annotated_mask, cmap='Reds', alpha=0.4)
    axes[1, 1].imshow(predicted_mask, cmap='Blues', alpha=0.4)
    axes[1, 1].set_title('Ground Truth (Red) + Predicted (Blue)', fontsize=14, fontweight='bold')
    axes[1, 1].axis('off')

    plt.tight_layout()

    # Save if requested
    if save_path:
        plt.savefig(save_path, dpi=300, bbox_inches='tight')
        print(f"Overlay comparison saved to: {save_path}")

    # Show if requested
    if show_plot:
        plt.show()
    else:
        plt.close()

    return fig

def compare_all_images(original_dir, annotated_dir, predicted_dir, output_dir=None,
                      max_images=None, comparison_type='side_by_side', show_plots=True):
    """
    Create comparisons for all matching images

    Args:
        original_dir: Directory with original images
        annotated_dir: Directory with annotated masks
        predicted_dir: Directory with predicted masks
        output_dir: Directory to save comparisons (optional)
        max_images: Maximum number of images to process (None for all)
        comparison_type: 'side_by_side' or 'overlay'
        show_plots: Whether to display plots

    Returns:
        Number of comparisons created
    """
    # Find matching files
    matches = find_matching_files(original_dir, annotated_dir, predicted_dir)

    if not matches:
        print("No matching files found across all three directories!")
        print(f"Original dir: {len(glob.glob(os.path.join(original_dir, '*')))} files")
        print(f"Annotated dir: {len(glob.glob(os.path.join(annotated_dir, '*')))} files")
        print(f"Predicted dir: {len(glob.glob(os.path.join(predicted_dir, '*')))} files")
        return 0

    print(f"Found {len(matches)} matching image sets")

    # Limit number of images if specified
    if max_images:
        matches = matches[:max_images]
        print(f"Processing first {len(matches)} images")

    # Create output directory if saving
    if output_dir:
        os.makedirs(output_dir, exist_ok=True)

    # Process each match
    for i, (original_path, annotated_path, predicted_path) in enumerate(matches):
        try:
            base_name = os.path.splitext(os.path.basename(original_path))[0]

            # Determine save path
            save_path = None
            if output_dir:
                save_filename = f"comparison_{comparison_type}_{base_name}.png"
                save_path = os.path.join(output_dir, save_filename)

            # Create comparison
            if comparison_type == 'overlay':
                create_overlay_comparison(original_path, annotated_path, predicted_path,
                                        save_path, show_plots)
            else:  # side_by_side
                create_comparison_plot(original_path, annotated_path, predicted_path,
                                     save_path, show_plots)

            print(f"Processed {i+1}/{len(matches)}: {base_name}")

        except Exception as e:
            print(f"Error processing {base_name}: {str(e)}")
            continue

    print(f"\nCompleted processing {len(matches)} image comparisons")
    if output_dir:
        print(f"Saved comparisons to: {output_dir}")

    return len(matches)

# Example usage function
def main_comparison():
    """
    Main function to run comparisons - update paths as needed
    """
    # UPDATE THESE PATHS TO YOUR ACTUAL DIRECTORIES
    original_images_dir = "/content/drive/MyDrive/AutonomousDrone/Building Dataset/Combined Data"
    annotated_masks_dir = "/content/drive/MyDrive/AutonomousDrone/Building Dataset/Arjun/masks"
    predicted_masks_dir = "/content/drive/MyDrive/AutonomousDrone/Building Dataset/Arjun/predicted_masks"
    output_comparisons_dir = "/content/drive/MyDrive/AutonomousDrone/Building Dataset/Arjun/comparisons"

    # Option 1: Side-by-side comparison
    print("Creating side-by-side comparisons...")
    compare_all_images(
        original_dir=original_images_dir,
        annotated_dir=annotated_masks_dir,
        predicted_dir=predicted_masks_dir,
        output_dir=output_comparisons_dir,
        max_images=None,  # Process first 5 images, set to None for all
        comparison_type='side_by_side',
        show_plots=True
    )

    # Option 2: Overlay comparison
    #print("\nCreating overlay comparisons...")
    #compare_all_images(
        #original_dir=original_images_dir,
        #annotated_dir=annotated_masks_dir,
        #predicted_dir=predicted_masks_dir,
        #output_dir=output_comparisons_dir,
        #max_images=5,
        #comparison_type='overlay',
        #show_plots=True
    #)

if __name__ == "__main__":
    # Update the paths in main_comparison() function above, then run:
    main_comparison()
    #print("Update the directory paths in main_comparison() and run the function!")

import matplotlib.pyplot as plt
import numpy as np
import cv2
import os
import glob
from PIL import Image
import re

def find_matching_pairs(images_dir, masks_dir, mask_suffix="_mask"):
    """
    Find matching image and mask pairs

    Args:
        images_dir: Directory containing original images
        masks_dir: Directory containing mask images
        mask_suffix: Suffix added to mask files (e.g., "_mask")

    Returns:
        List of tuples (image_path, mask_path, base_name)
    """
    # Get all image files
    image_extensions = ['*.png', '*.jpg', '*.jpeg', '*.tiff', '*.bmp', '*.PNG', '*.JPG', '*.JPEG']

    # Find original images
    image_files = []
    for ext in image_extensions:
        image_files.extend(glob.glob(os.path.join(images_dir, ext)))

    # Find mask files
    mask_files = []
    for ext in image_extensions:
        mask_files.extend(glob.glob(os.path.join(masks_dir, ext)))

    # Create dictionaries for easier matching
    image_dict = {}
    for image_path in image_files:
        filename = os.path.basename(image_path)
        base_name = os.path.splitext(filename)[0]
        image_dict[base_name] = image_path

    mask_dict = {}
    for mask_path in mask_files:
        filename = os.path.basename(mask_path)
        base_name = os.path.splitext(filename)[0]
        # Remove mask suffix to get original name
        if mask_suffix in base_name:
            original_name = base_name.replace(mask_suffix, '')
            mask_dict[original_name] = mask_path

    # Find matching pairs
    matches = []
    for base_name in image_dict.keys():
        if base_name in mask_dict:
            matches.append((image_dict[base_name], mask_dict[base_name], base_name))

    return matches

def load_and_prepare_image(image_path, is_mask=False):
    """
    Load and prepare image for display

    Args:
        image_path: Path to image file
        is_mask: Whether this is a mask image

    Returns:
        Processed image array
    """
    # Load image using PIL first, then convert to numpy
    try:
        image = Image.open(image_path)
        image_array = np.array(image)

        # Handle different image formats
        if len(image_array.shape) == 3 and image_array.shape[2] == 3:
            # RGB image - no conversion needed for matplotlib
            if not is_mask:
                processed_image = image_array
            else:
                # Convert color mask to grayscale
                processed_image = cv2.cvtColor(image_array, cv2.COLOR_RGB2GRAY)
        elif len(image_array.shape) == 2:
            # Grayscale image
            processed_image = image_array
        else:
            # RGBA or other formats
            if image_array.shape[2] == 4:  # RGBA
                processed_image = cv2.cvtColor(image_array, cv2.COLOR_RGBA2RGB)
                if is_mask:
                    processed_image = cv2.cvtColor(processed_image, cv2.COLOR_RGB2GRAY)
            else:
                processed_image = image_array

        return processed_image

    except Exception as e:
        print(f"Error loading {image_path}: {e}")
        return None

def create_side_by_side_comparison(image_path, mask_path, base_name, save_path=None, show_plot=True):
    """
    Create side-by-side comparison of image and mask

    Args:
        image_path: Path to original image
        mask_path: Path to mask image
        base_name: Base name for the files
        save_path: Path to save the comparison (optional)
        show_plot: Whether to display the plot

    Returns:
        Figure object
    """
    # Load images
    original_img = load_and_prepare_image(image_path, is_mask=False)
    mask_img = load_and_prepare_image(mask_path, is_mask=True)

    if original_img is None or mask_img is None:
        print(f"Failed to load images for {base_name}")
        return None

    # Create figure
    fig, axes = plt.subplots(1, 2, figsize=(16, 8))

    # Original image
    axes[0].imshow(original_img)
    axes[0].set_title(f'Original Image\n{base_name}', fontsize=14, fontweight='bold')
    axes[0].axis('off')

    # Mask image
    axes[1].imshow(mask_img, cmap='gray')
    axes[1].set_title(f'Mask\n{os.path.basename(mask_path)}', fontsize=14, fontweight='bold')
    axes[1].axis('off')

    plt.tight_layout()

    # Save if requested
    if save_path:
        plt.savefig(save_path, dpi=300, bbox_inches='tight')
        print(f"Comparison saved to: {save_path}")

    # Show if requested
    if show_plot:
        plt.show()
    else:
        plt.close()

    return fig

def create_overlay_comparison(image_path, mask_path, base_name, save_path=None, show_plot=True):
    """
    Create comparison with mask overlaid on original image

    Args:
        image_path: Path to original image
        mask_path: Path to mask image
        base_name: Base name for the files
        save_path: Path to save the comparison (optional)
        show_plot: Whether to display the plot
    """
    # Load images
    original_img = load_and_prepare_image(image_path, is_mask=False)
    mask_img = load_and_prepare_image(mask_path, is_mask=True)

    if original_img is None or mask_img is None:
        print(f"Failed to load images for {base_name}")
        return None

    # Resize mask to match original image if needed
    if original_img.shape[:2] != mask_img.shape[:2]:
        mask_img = cv2.resize(mask_img, (original_img.shape[1], original_img.shape[0]))

    # Create binary mask for overlay
    binary_mask = (mask_img > 127).astype(float)

    # Create figure with three panels
    fig, axes = plt.subplots(1, 3, figsize=(24, 8))

    # Original image
    axes[0].imshow(original_img)
    axes[0].set_title(f'Original Image\n{base_name}', fontsize=14, fontweight='bold')
    axes[0].axis('off')

    # Mask only
    axes[1].imshow(mask_img, cmap='gray')
    axes[1].set_title(f'Mask\n{os.path.basename(mask_path)}', fontsize=14, fontweight='bold')
    axes[1].axis('off')

    # Overlay
    axes[2].imshow(original_img)
    axes[2].imshow(binary_mask, cmap='Reds', alpha=0.5)
    axes[2].set_title(f'Overlay\n{base_name} + Mask', fontsize=14, fontweight='bold')
    axes[2].axis('off')

    plt.tight_layout()

    # Save if requested
    if save_path:
        plt.savefig(save_path, dpi=300, bbox_inches='tight')
        print(f"Overlay comparison saved to: {save_path}")

    # Show if requested
    if show_plot:
        plt.show()
    else:
        plt.close()

    return fig

def visualize_all_pairs(images_dir, masks_dir, output_dir=None, max_pairs=None,
                       comparison_type='side_by_side', mask_suffix="_mask", show_plots=True):
    """
    Create visualizations for all matching image-mask pairs

    Args:
        images_dir: Directory with original images
        masks_dir: Directory with mask images
        output_dir: Directory to save comparisons (optional)
        max_pairs: Maximum number of pairs to process (None for all)
        comparison_type: 'side_by_side' or 'overlay'
        mask_suffix: Suffix used in mask filenames
        show_plots: Whether to display plots

    Returns:
        Number of visualizations created
    """
    # Find matching pairs
    matches = find_matching_pairs(images_dir, masks_dir, mask_suffix)

    if not matches:
        print("No matching image-mask pairs found!")
        print(f"Images directory: {images_dir}")
        print(f"Masks directory: {masks_dir}")
        print(f"Looking for mask suffix: '{mask_suffix}'")
        return 0

    print(f"Found {len(matches)} matching pairs")

    # Limit number of pairs if specified
    if max_pairs:
        matches = matches[:max_pairs]
        print(f"Processing first {len(matches)} pairs")

    # Create output directory if saving
    if output_dir:
        os.makedirs(output_dir, exist_ok=True)

    # Process each pair
    successful = 0
    for i, (image_path, mask_path, base_name) in enumerate(matches):
        try:
            print(f"Processing {i+1}/{len(matches)}: {base_name}")

            # Determine save path
            save_path = None
            if output_dir:
                save_filename = f"comparison_{comparison_type}_{base_name}.png"
                save_path = os.path.join(output_dir, save_filename)

            # Create comparison
            if comparison_type == 'overlay':
                fig = create_overlay_comparison(image_path, mask_path, base_name,
                                              save_path, show_plots)
            else:  # side_by_side
                fig = create_side_by_side_comparison(image_path, mask_path, base_name,
                                                   save_path, show_plots)

            if fig is not None:
                successful += 1

        except Exception as e:
            print(f"Error processing {base_name}: {str(e)}")
            continue

    print(f"\nCompleted processing {successful}/{len(matches)} pairs")
    if output_dir:
        print(f"Saved comparisons to: {output_dir}")

    return successful

def visualize_specific_pair(images_dir, masks_dir, filename, mask_suffix="_mask",
                          comparison_type='side_by_side'):
    """
    Visualize a specific image-mask pair

    Args:
        images_dir: Directory with original images
        masks_dir: Directory with mask images
        filename: Name of the image file (without extension) or full filename
        mask_suffix: Suffix used in mask filenames
        comparison_type: 'side_by_side' or 'overlay'
    """
    # Remove extension if provided
    base_name = os.path.splitext(filename)[0]

    # Find the actual files
    matches = find_matching_pairs(images_dir, masks_dir, mask_suffix)

    target_pair = None
    for image_path, mask_path, match_base_name in matches:
        if match_base_name == base_name:
            target_pair = (image_path, mask_path, match_base_name)
            break

    if target_pair is None:
        print(f"No matching pair found for: {filename}")
        print("Available pairs:")
        for _, _, match_base_name in matches[:]:
            print(f"  {match_base_name}")
        return

    image_path, mask_path, base_name = target_pair

    # Create visualization
    if comparison_type == 'overlay':
        create_overlay_comparison(image_path, mask_path, base_name, show_plot=True)
    else:
        create_side_by_side_comparison(image_path, mask_path, base_name, show_plot=True)

# Example usage functions
def main_visualization():
    """
    Main function to run visualizations - update paths as needed
    """
    # UPDATE THESE PATHS TO YOUR ACTUAL DIRECTORIES
    images_directory = "/content/drive/MyDrive/AutonomousDrone/Building Dataset/Arjun/Drone Images"
    masks_directory = "/content/drive/MyDrive/AutonomousDrone/Building Dataset/Arjun/Drone Predictions"
    output_directory = "/content/drive/MyDrive/AutonomousDrone/Building Dataset/Arjun/Drone Images Side by Side"

    # Visualize all pairs
    print("Creating side-by-side comparisons...")
    visualize_all_pairs(
        images_dir=images_directory,
        masks_dir=masks_directory,
        output_dir=output_directory,
        max_pairs=None,  # Process first 5 pairs, set to None for all
        comparison_type='side_by_side',
        mask_suffix="_mask",  # Adjust if your masks have different suffix
        show_plots=True
    )

main_visualization()

"""#Find heights"""



import numpy as np
from PIL import Image
import os
import glob

def get_pixel_height(mask_path):
    """
    Get the height from lowest white pixel to highest white pixel

    Args:
        mask_path: Path to the mask image

    Returns:
        int: Height in pixels, or 0 if no white pixels found
    """
    # Load mask
    mask_img = Image.open(mask_path)

    # Convert to grayscale if needed
    if mask_img.mode != 'L':
        mask_img = mask_img.convert('L')

    # Convert to numpy array
    mask = np.array(mask_img)

    # Find white pixels (assuming white = buildings, black = background)
    white_pixels = np.where(mask > 127)  # Threshold at middle gray

    if len(white_pixels[0]) == 0:
        return 0  # No white pixels found

    # Get row indices of white pixels
    white_rows = white_pixels[0]

    # Find topmost (minimum row) and bottommost (maximum row) white pixels
    top_pixel = np.min(white_rows)
    bottom_pixel = np.max(white_rows)

    # Calculate height
    height = bottom_pixel - top_pixel + 1

    return height

FOLDER_PATH = '/content/drive/MyDrive/AutonomousDrone/Building Dataset/Arjun/predicted_masks'
OG_PATH = '/content/drive/MyDrive/AutonomousDrone/Building Dataset/Arjun/masks'

predicted_heights = []
predicted_images= []
annotated_heights = []
annotated_images = []
differences = []

for img in os.listdir(FOLDER_PATH):
  predicted_heights.append(get_pixel_height(f"{FOLDER_PATH}" + f"/{img}"))
  predicted_images.append(img)

for img in os.listdir(OG_PATH):
  annotated_heights.append(get_pixel_height(f"{OG_PATH}" + f"/{img}"))
  annotated_images.append(img)

for i in range(len(predicted_heights)):
  if (predicted_images[i] in annotated_images):
    j = annotated_images.index(predicted_images[i])
    differences.append(int((predicted_heights[i] - annotated_heights[j])))
    #print(f"Predicted Height: {predicted_heights[i]} Real height: {annotated_heights[j]} Difference: {abs(predicted_heights[i] - annotated_heights[j])}")


print(differences)

import matplotlib.pyplot as plt

plt.figure(figsize=(8, 6))
plt.hist(differences, bins=30)
plt.title('Basic Histogram')
plt.xlabel('Values')
plt.ylabel('Frequency')
plt.show()

"""#Using the masks to find the highest and lowest (x,y) coordinates"""

import numpy as np
from PIL import Image

def get_coordinates(image_path):
    """Get highest and lowest (x,y) coordinates of white pixels"""
    mask_img = Image.open(image_path)

    if mask_img.mode != 'L':
        mask_img = mask_img.convert('L')

    mask = np.array(mask_img)
    white_pixels = np.where(mask > 127)
`ZA
    if len(white_pixels[0]) == 0:
        return None

    white_rows = white_pixels[0]
    white_cols = white_pixels[1]

    top_row = np.min(white_rows)
    bottom_row = np.max(white_rows)

    top_index = np.where(white_rows == top_row)[0][0]
    bottom_index = np.where(white_rows == bottom_row)[0][0]

    top_coords = (white_cols[top_index], white_rows[top_index])
    bottom_coords = (white_cols[bottom_index], white_rows[bottom_index])

    return top_coords, bottom_coords

def compare_two_images(image1_path, image2_path):
    """Compare two images and print coordinates"""
    result1 = get_coordinates(image1_path)
    result2 = get_coordinates(image2_path)

    print(f"Image 1: highest: {result1[0]}, lowest: {result1[1]}")
    print(f"Image 2: highest: {result2[0]}, lowest: {result2[1]}")

# Usage
compare_two_images(
    '/content/drive/MyDrive/AutonomousDrone/Building Dataset/Arjun/Drone Predictions/DJI_0001_mask.png',
    '/content/drive/MyDrive/AutonomousDrone/Building Dataset/Arjun/Drone Predictions/DJI_0002_mask.png'
)

"""#Pablo's dfs implementation"""

"""
maskCleaning.py

This module is utilized to clean up the
building masks produced by our DeepLearningV3
model. The way it is cleaned up is through a
graph-traversal problem, where we try to find the
largest group of interconnected 1s in a 2D
binary array, where a 1 represents a building
pixel. The DFS implementation is at worst
quadratic time, or O(nm) where n is num of
cols and m is num of rows.

Author: Pablo Silva
Date: 07-27-2025
Last Updated: 07-27-2025
"""

from PIL import Image
import numpy as np
import sys
import os

recursion_limit = 5000000
sys.setrecursionlimit(recursion_limit)

def dfs_search(binary_array):
    """
    Implementation that first checks for
    rows and columns, then uses DFS to find
    largest group. After largest group is found,
    any other sub-group is converted to 0s.
    """
    rows = len(binary_array)
    cols = len(binary_array[0])

    # Keep original for debugging
    binary_array = [row[:] for row in binary_array]

    # Visited cells during DFS
    visited = [[False for _ in range(cols)] for _ in range(rows)]

    largest_group_size = 0
    largest_group = []

    def dfs(r, c, current_group):
        """
        Implementation of depth first search,
        where r is number of rows and c is number
        of columns. It first starts by detecting a 1,
        then traversing (or backtracking) recursively
        for other nearby (horizontally/vertically) connected
        nodes. It returns through recursion by calling the parent
        node. Also, its important that it uses a stack
        (LIFO) to keep track of visited nodes, thus
        avoiding cycles aka infinite loops.
        """
        if (r < 0 or r >= rows or c < 0 or c >= cols or
                visited[r][c] or binary_array[r][c] == 0):
            return 0

        visited[r][c] = True
        current_group.append((r, c))
        count = 1  # Count current node

        # Explore neighbor nodes
        count += dfs(r + 1, c, current_group) # Down
        count += dfs(r - 1, c, current_group) # Up
        count += dfs(r, c + 1, current_group) # Right
        count += dfs(r, c - 1, current_group) # Left

        return count

    # Comparison, filter through largest group.
    for r in range(rows):
        for c in range(cols):
            if binary_array[r][c] == 1 and not visited[r][c]:
                current_group = []
                current_group_size = dfs(r, c, current_group)

                if current_group_size > largest_group_size:
                    largest_group_size = current_group_size
                    largest_group = current_group

                # If multiple groups are the same size, first one found is kept
                elif current_group_size == largest_group_size:
                    pass

    # Create output array, set non-largest to 0s
    output_array = [[0 for _ in range(cols)] for _ in range(rows)]
    for r, c in largest_group:
        output_array[r][c] = 1

    return output_array

def png_conversion(binary_array, output_path="output_mask.png"):
    """
    Converts a 2D binary array (0s and 1s) into a black and white PNG image.
    Note that the binary_array MUST be normalized to 0 and 1, and the output
    path can be editted if needed. Also assumes input validation.
    """

    height = len(binary_array)
    width = len(binary_array[0])

    # Creates 1-bit image
    img = Image.new('1', (width, height))
    pixels = img.load() # Get a pixel access object

    # Iterate through the binary array and set pixel values
    for y in range(height):
        for x in range(width):
            # If value = 1, set to white
            # If value = 0, set to black
            pixels[x, y] = binary_array[y][x] * 255

    # Save the image
    try:
        img.save(output_path)
        print(f"Image successfully saved to {output_path}")
    except Exception as e:
        print(f"Error saving image: {e}")

directory = '/content/drive/MyDrive/AutonomousDrone/Building Dataset/Arjun/Drone Predictions'

for image in os.listdir(directory):


  img_file = directory + "/" + image # To save new images
  img = Image.open(img_file).convert('L')

  np_img = np.array(img)
  binary_array = (np_img > 128).astype(int)
  result_array = dfs_search(binary_array)

  filename_only = img_file.split('/')[-1]
  output_path = f"/content/drive/MyDrive/AutonomousDrone/Building Dataset/Arjun/{filename_only}"
  png_conversion(result_array, output_path)

import matplotlib.pyplot as plt
import numpy as np
import cv2
import os
import glob
from PIL import Image
import re

def find_matching_mask_pairs(uncleaned_dir, cleaned_dir, clean_suffix="_clean"):
    """
    Find matching uncleaned and cleaned mask pairs

    Args:
        uncleaned_dir: Directory containing uncleaned mask images
        cleaned_dir: Directory containing cleaned mask images
        clean_suffix: Suffix added to cleaned files (e.g., "_clean")

    Returns:
        List of tuples (uncleaned_path, cleaned_path, base_name)
    """
    # Get all image files
    image_extensions = ['*.png', '*.jpg', '*.jpeg', '*.tiff', '*.bmp', '*.PNG', '*.JPG', '*.JPEG']

    # Find uncleaned mask files
    uncleaned_files = []
    for ext in image_extensions:
        uncleaned_files.extend(glob.glob(os.path.join(uncleaned_dir, ext)))

    # Find cleaned mask files
    cleaned_files = []
    for ext in image_extensions:
        cleaned_files.extend(glob.glob(os.path.join(cleaned_dir, ext)))

    # Create dictionaries for easier matching
    uncleaned_dict = {}
    for uncleaned_path in uncleaned_files:
        filename = os.path.basename(uncleaned_path)
        base_name = os.path.splitext(filename)[0]
        uncleaned_dict[base_name] = uncleaned_path

    cleaned_dict = {}
    for cleaned_path in cleaned_files:
        filename = os.path.basename(cleaned_path)
        # Handle the naming pattern: DJI_0001_mask.png_clean.png
        if filename.endswith('.png_clean.png'):
            # Remove .png_clean.png and get the base name
            original_name = filename.replace('.png_clean.png', '')
            cleaned_dict[original_name] = cleaned_path
        elif clean_suffix in filename:
            # Fallback for other clean suffix patterns
            base_name = os.path.splitext(filename)[0]
            original_name = base_name.replace(clean_suffix, '')
            cleaned_dict[original_name] = cleaned_path

    # Find matching pairs
    matches = []
    for base_name in uncleaned_dict.keys():
        if base_name in cleaned_dict:
            matches.append((uncleaned_dict[base_name], cleaned_dict[base_name], base_name))

    return matches

def load_and_prepare_image(image_path, is_mask=True):
    """
    Load and prepare image for display

    Args:
        image_path: Path to image file
        is_mask: Whether this is a mask image (default True since we're comparing masks)

    Returns:
        Processed image array
    """
    # Load image using PIL first, then convert to numpy
    try:
        image = Image.open(image_path)
        image_array = np.array(image)

        # Handle different image formats
        if len(image_array.shape) == 3 and image_array.shape[2] == 3:
            # RGB image - convert to grayscale for masks
            processed_image = cv2.cvtColor(image_array, cv2.COLOR_RGB2GRAY)
        elif len(image_array.shape) == 2:
            # Grayscale image
            processed_image = image_array
        else:
            # RGBA or other formats
            if image_array.shape[2] == 4:  # RGBA
                processed_image = cv2.cvtColor(image_array, cv2.COLOR_RGBA2RGB)
                processed_image = cv2.cvtColor(processed_image, cv2.COLOR_RGB2GRAY)
            else:
                processed_image = image_array

        return processed_image

    except Exception as e:
        print(f"Error loading {image_path}: {e}")
        return None

def create_side_by_side_comparison(uncleaned_path, cleaned_path, base_name, save_path=None, show_plot=True):
    """
    Create side-by-side comparison of uncleaned and cleaned masks

    Args:
        uncleaned_path: Path to uncleaned mask
        cleaned_path: Path to cleaned mask
        base_name: Base name for the files
        save_path: Path to save the comparison (optional)
        show_plot: Whether to display the plot

    Returns:
        Figure object
    """
    # Load images
    uncleaned_mask = load_and_prepare_image(uncleaned_path, is_mask=True)
    cleaned_mask = load_and_prepare_image(cleaned_path, is_mask=True)

    if uncleaned_mask is None or cleaned_mask is None:
        print(f"Failed to load masks for {base_name}")
        return None

    # Create figure
    fig, axes = plt.subplots(1, 2, figsize=(16, 8))

    # Uncleaned mask
    axes[0].imshow(uncleaned_mask, cmap='gray')
    axes[0].set_title(f'Uncleaned Mask\n{base_name}', fontsize=14, fontweight='bold')
    axes[0].axis('off')

    # Cleaned mask
    axes[1].imshow(cleaned_mask, cmap='gray')
    axes[1].set_title(f'Cleaned Mask\n{os.path.basename(cleaned_path)}', fontsize=14, fontweight='bold')
    axes[1].axis('off')

    plt.tight_layout()

    # Save if requested
    if save_path:
        plt.savefig(save_path, dpi=300, bbox_inches='tight')
        print(f"Comparison saved to: {save_path}")

    # Show if requested
    if show_plot:
        plt.show()
    else:
        plt.close()

    return fig

def create_overlay_comparison(uncleaned_path, cleaned_path, base_name, save_path=None, show_plot=True):
    """
    Create comparison with uncleaned and cleaned masks overlaid

    Args:
        uncleaned_path: Path to uncleaned mask
        cleaned_path: Path to cleaned mask
        base_name: Base name for the files
        save_path: Path to save the comparison (optional)
        show_plot: Whether to display the plot
    """
    # Load images
    uncleaned_mask = load_and_prepare_image(uncleaned_path, is_mask=True)
    cleaned_mask = load_and_prepare_image(cleaned_path, is_mask=True)

    if uncleaned_mask is None or cleaned_mask is None:
        print(f"Failed to load masks for {base_name}")
        return None

    # Resize cleaned mask to match uncleaned mask if needed
    if uncleaned_mask.shape[:2] != cleaned_mask.shape[:2]:
        cleaned_mask = cv2.resize(cleaned_mask, (uncleaned_mask.shape[1], uncleaned_mask.shape[0]))

    # Create binary masks for overlay
    uncleaned_binary = (uncleaned_mask > 127).astype(float)
    cleaned_binary = (cleaned_mask > 127).astype(float)

    # Create figure with three panels
    fig, axes = plt.subplots(1, 3, figsize=(24, 8))

    # Uncleaned mask
    axes[0].imshow(uncleaned_mask, cmap='gray')
    axes[0].set_title(f'Uncleaned Mask\n{base_name}', fontsize=14, fontweight='bold')
    axes[0].axis('off')

    # Cleaned mask
    axes[1].imshow(cleaned_mask, cmap='gray')
    axes[1].set_title(f'Cleaned Mask\n{os.path.basename(cleaned_path)}', fontsize=14, fontweight='bold')
    axes[1].axis('off')

    # Overlay comparison
    # Show removed areas in red and kept areas in green
    overlay_img = np.zeros((*uncleaned_mask.shape, 3))
    overlay_img[:, :, 0] = uncleaned_binary - cleaned_binary  # Red for removed areas
    overlay_img[:, :, 1] = cleaned_binary  # Green for kept areas

    axes[2].imshow(overlay_img)
    axes[2].set_title(f'Overlay Comparison\nRed: Removed, Green: Kept', fontsize=14, fontweight='bold')
    axes[2].axis('off')

    plt.tight_layout()

    # Save if requested
    if save_path:
        plt.savefig(save_path, dpi=300, bbox_inches='tight')
        print(f"Overlay comparison saved to: {save_path}")

    # Show if requested
    if show_plot:
        plt.show()
    else:
        plt.close()

    return fig

def visualize_all_pairs(uncleaned_dir, cleaned_dir, output_dir=None, max_pairs=None,
                       comparison_type='side_by_side', show_plots=True):
    """
    Create visualizations for all matching uncleaned-cleaned mask pairs

    Args:
        uncleaned_dir: Directory with uncleaned mask images
        cleaned_dir: Directory with cleaned mask images
        output_dir: Directory to save comparisons (optional)
        max_pairs: Maximum number of pairs to process (None for all)
        comparison_type: 'side_by_side' or 'overlay'
        show_plots: Whether to display plots

    Returns:
        Number of visualizations created
    """
    # Find matching pairs
    matches = find_matching_mask_pairs(uncleaned_dir, cleaned_dir)

    if not matches:
        print("No matching uncleaned-cleaned mask pairs found!")
        print(f"Uncleaned directory: {uncleaned_dir}")
        print(f"Cleaned directory: {cleaned_dir}")
        print("Expected naming: uncleaned = 'DJI_0001_mask.png', cleaned = 'DJI_0001_mask.png_clean.png'")
        return 0

    print(f"Found {len(matches)} matching pairs")

    # Limit number of pairs if specified
    if max_pairs:
        matches = matches[:max_pairs]
        print(f"Processing first {len(matches)} pairs")

    # Create output directory if saving
    if output_dir:
        os.makedirs(output_dir, exist_ok=True)

    # Process each pair
    successful = 0
    for i, (uncleaned_path, cleaned_path, base_name) in enumerate(matches):
        try:
            print(f"Processing {i+1}/{len(matches)}: {base_name}")

            # Determine save path
            save_path = None
            if output_dir:
                save_filename = f"mask_comparison_{comparison_type}_{base_name}.png"
                save_path = os.path.join(output_dir, save_filename)

            # Create comparison
            if comparison_type == 'overlay':
                fig = create_overlay_comparison(uncleaned_path, cleaned_path, base_name,
                                              save_path, show_plots)
            else:  # side_by_side
                fig = create_side_by_side_comparison(uncleaned_path, cleaned_path, base_name,
                                                   save_path, show_plots)

            if fig is not None:
                successful += 1

        except Exception as e:
            print(f"Error processing {base_name}: {str(e)}")
            continue

    print(f"\nCompleted processing {successful}/{len(matches)} pairs")
    if output_dir:
        print(f"Saved comparisons to: {output_dir}")

    return successful

def visualize_specific_pair(uncleaned_dir, cleaned_dir, filename, comparison_type='side_by_side'):
    """
    Visualize a specific uncleaned-cleaned mask pair

    Args:
        uncleaned_dir: Directory with uncleaned mask images
        cleaned_dir: Directory with cleaned mask images
        filename: Name of the mask file (without extension) or full filename
        comparison_type: 'side_by_side' or 'overlay'
    """
    # Remove extension if provided
    base_name = os.path.splitext(filename)[0]

    # Find the actual files
    matches = find_matching_mask_pairs(uncleaned_dir, cleaned_dir)

    target_pair = None
    for uncleaned_path, cleaned_path, match_base_name in matches:
        if match_base_name == base_name:
            target_pair = (uncleaned_path, cleaned_path, match_base_name)
            break

    if target_pair is None:
        print(f"No matching pair found for: {filename}")
        print("Available pairs:")
        for _, _, match_base_name in matches[:10]:  # Show first 10
            print(f"  {match_base_name}")
        return

    uncleaned_path, cleaned_path, base_name = target_pair

    # Create visualization
    if comparison_type == 'overlay':
        create_overlay_comparison(uncleaned_path, cleaned_path, base_name, show_plot=True)
    else:
        create_side_by_side_comparison(uncleaned_path, cleaned_path, base_name, show_plot=True)

# Example usage functions
def main_visualization():
    """
    Main function to run visualizations - update paths as needed
    """
    # UPDATE THESE PATHS TO YOUR ACTUAL DIRECTORIES
    uncleaned_directory = "/content/drive/MyDrive/AutonomousDrone/Building Dataset/Arjun/Drone Predictions"
    cleaned_directory = "/content/drive/MyDrive/AutonomousDrone/Building Dataset/Arjun/cleaned predicted masks"
    output_directory = "/content/drive/MyDrive/AutonomousDrone/Building Dataset/Arjun/clean vs unclean comparisons"

    # Visualize all pairs
    print("Creating uncleaned vs cleaned mask comparisons...")
    visualize_all_pairs(
        uncleaned_dir=uncleaned_directory,
        cleaned_dir=cleaned_directory,
        output_dir=output_directory,
        max_pairs=None,  # Process all pairs, set to a number to limit
        comparison_type='side_by_side',  # or 'overlay'
        show_plots=True
    )

main_visualization()